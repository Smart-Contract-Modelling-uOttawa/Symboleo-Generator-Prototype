/*
 * generated by Xtext 2.22.0
 */
package org.xtext.example.symg.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.symg.symg.Model
import org.xtext.example.symg.symg.Obligation
import org.xtext.example.symg.symg.Proposition
import org.xtext.example.symg.symg.Junction
import org.xtext.example.symg.symg.Negation
import org.xtext.example.symg.symg.Atom
import org.xtext.example.symg.symg.EventProp
import org.xtext.example.symg.symg.SitProp
import org.xtext.example.symg.symg.oEvent
import org.xtext.example.symg.symg.cEvent
import org.xtext.example.symg.symg.pEvent
import org.xtext.example.symg.symg.oState
import org.xtext.example.symg.symg.cState
import org.xtext.example.symg.symg.pState
import org.xtext.example.symg.symg.SitName
import org.xtext.example.symg.symg.Point
import org.xtext.example.symg.symg.Power
import org.xtext.example.symg.symg.Interval
import java.util.HashMap
import org.xtext.example.symg.symg.Regular
import org.xtext.example.symg.symg.Enumeration
import org.xtext.example.symg.symg.DomainType
import org.xtext.example.symg.symg.BasicType
import org.xtext.example.symg.symg.OntoCType
import java.util.ArrayList
import java.util.HashSet
import org.xtext.example.symg.generator.KeyValuePair;
import java.lang.Math;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SymgGenerator extends AbstractGenerator {
	//-----------------------------------------------------------------------//
	//-----------------------Domain Concept Generator------------------------//
	//-----------------------------------------------------------------------//
	
	/**
	 * Generates prolog code for a regular domain concept
	 */
	def dispatch compileDomainConcept(Regular domainConcept, StringBuilder res, HashMap<String, String> superTypes) {
		domainConcept.conceptType.compileCType(domainConcept.name, res, superTypes)
	}
	
	/**
	 * compiles domain concept if its type is another domain concept
	 */
	def dispatch compileCType(DomainType dType, String dName, StringBuilder res, HashMap<String, String> superTypes) {
		res.append(dType.superType.name + "(X)\t:-\t" + dName + "(X).\n")
		superTypes.put(dName, dType.superType.name)
	}
	
	/**
	 * compiles domain concept if its type is a basic type
	 */
	def dispatch compileCType(BasicType bType, String dName, StringBuilder res, HashMap<String, String> superTypes) {
		res.append(bType.name + "(" + dName + ").\n")
		superTypes.put(dName, bType.name)
	}
	
	/**
	 * compiles domain concept if its type is an ontoctype
	 */
	def dispatch compileCType(OntoCType oType, String dName, StringBuilder res, HashMap<String, String> superTypes) {
		if (oType.name.equals('ROLE')) {
			res.append("ROLE(" + dName + ").\n")
		}
		else {
			res.append(oType.name + "(X)\t:-\t" + dName + "(X).\n")
		}
		superTypes.put(dName, oType.name)
	}
	
	/**
	 * Generates prolog code for an enumeration domain concept
	 */
	def dispatch compileDomainConcept(Enumeration domainConcept, StringBuilder res, HashMap<String, String> superTypes) {
		for (value : domainConcept.enumerationItems) {
			res.append(domainConcept.name + "(" + value.name + ").\n")
		}
		res.append("\n")
	}
	
	//-----------------------------------------------------------------------//
	//-------------------------Declaration Generator-------------------------//
	//-----------------------------------------------------------------------//
	
		/**
	 * Writes the underscores for assets/roles/dates in contract binding
	 */
	def contractUnderscoreHelper(String contractName, int before, int after, StringBuilder res) {
		res.append("initially(" + contractName + "(")
		for (i : 0..< before) {
			res.append("_,")
		}
		res.append("X")
		for (i : 0..< after) {
			res.append(",_")
		}
		res.append(")).\n")
	}
	
	/**
	 * Generates prolog code for declarations
	 */
	def compileDeclaration(String parent, String declName, StringBuilder res, HashMap<String, ArrayList<KeyValuePair>> declAttrs, HashSet<String> dates) {
		var i = 0
		for (attr: declAttrs.get(declName)) {

			if (declAttrs.containsKey(attr.value)) {
				// the value of this attribute is a declaration
				attr.value.compileDeclarations(res, declAttrs, dates)
			}
			// if the value is date in the parameters, ignore it
			if (!dates.contains(attr.value)) {
				res.append("holds_at(" + attr.key + "(" + parent + "," + attr.value + "),T)")	
				if (i < declAttrs.get(declName).length - 1) {
					res.append(",")
				}
			}
			i += 1
		}
	}
	
	/**
	 * Recursively generates prolog code for declaration attributes that are also declarations
	 */
	def compileDeclarations(String object, StringBuilder res, HashMap<String, ArrayList<KeyValuePair>> declAttrs, HashSet<String> dates) {
		for (attr: declAttrs.get(object)) {

			if (declAttrs.containsKey(attr.value)) {
				// the value of this attribute is a declaration
				attr.value.compileDeclarations(res, declAttrs, dates)
			}
			// if the value is date in the parameters, ignore it 
			if (!dates.contains(attr.value)) {
				res.append("holds_at(" + attr.key + "(" + object + "," + attr.value + "),T),")	
			}
		}
	}
	
	def compile(Model model) {
		var res = new StringBuilder()
		var superTypes = new HashMap<String, String>()
		var declAttrs = new HashMap<String, ArrayList<KeyValuePair>>()
		var declEvents = new HashSet<String>()
		var dates = new HashSet<String>()
		var roles = new HashSet<String>()
		var assets = new HashSet<String>()
		var underscoreAfter = 0
		var underscoreBefore = 0
		
		// compiling domain
		res.append("## Domain\n")
		for (domainConcept : model.domainConcepts) {
			domainConcept.compileDomainConcept(res, superTypes)
		}
			
		// count the number of contract parameters
		for (param: model.parameters) {
			var pType = param.type.checkParameterType(superTypes)
			if (pType.equals('ROLE') || pType.equals('DATE')) {
				if (pType.equals('ROLE')) {
					// add parameter name to roles
					roles.add(param.name)
				}
				if (pType.equals('DATE')) {
					// add parameter name to dates
					dates.add(param.name)
				}
				
				underscoreAfter += 1
			}
		}
		
		// count the number of contract parameters
		// map attributes/attribute values to the names of declarations
		// let's just consider that assets will always be formed in declarations from basic types
		for (declaration : model.declarations) {
			var parentType = declaration.type.name
			var attrs = new ArrayList<KeyValuePair>()
			
			while (superTypes.containsKey(parentType)) {
				parentType = superTypes.get(parentType)
			}
			
			if (parentType.equals('ASSET')) {
				assets.add(declaration.name)
				underscoreAfter += 1
			}
			if (parentType.equals('EVENT')) {
				// keeps track of all declarations that are events
				declEvents.add(declaration.name)
			}
			
			// adding pair value pairs of each declaration attribute to arr list
			for (attribute: declaration.attributes) {
				attrs.add(new KeyValuePair(attribute.attr, attribute.param))
			}
			
			declAttrs.put(declaration.name, attrs)
		}
		
		// initialize contract
		// I'm guessing length of contract = #roles + #dates + #assets + 1
		res.append("\n## Contract\n")	
		res.append("c(X)\t:-\t")
		contractUnderscoreHelper(model.contractName, underscoreBefore, underscoreAfter, res)
		res.append("\n")
		underscoreAfter -= 1
		underscoreBefore += 1
		
		for (role : roles) {
			res.append("initially(bind(" + role + ",X))\t:-\t")
			contractUnderscoreHelper(model.contractName, underscoreBefore, underscoreAfter, res)
			underscoreAfter -= 1
			underscoreBefore += 1
		}
		
		for (date : dates) {
			res.append(date + "(X)\t:-\t")
			contractUnderscoreHelper(model.contractName, underscoreBefore, underscoreAfter, res)
			underscoreAfter -= 1
			underscoreBefore += 1
		}
		
		for (asset : assets) {
			res.append(asset + "(X)")
			contractUnderscoreHelper(model.contractName, underscoreBefore, underscoreAfter, res)
			underscoreAfter -= 1
			underscoreBefore += 1
		}
		
		res.append("initially(form(X))\t:-\t")
		contractUnderscoreHelper(model.contractName, underscoreBefore-1, underscoreAfter, res)
		
		// initialize declarations
		res.append("\n## Declarations\n")
		// compile declaration events
		for (d : declAttrs.keySet) {
			if (declEvents.contains(d)) {
				res.append(d + "(E)\t:-\t")
				res.append("happens(E,T),holds_at(type(E," + d + ")),")
				"E".compileDeclaration(d, res, declAttrs, dates)		
				res.append(".\n")
			}
		}
		
		res.append("\n## Obligations\n")
		// compiling obligations
		for (i : 0 ..< model.obligations.length) {
			model.obligations.get(i).compileObligations(i+1, res, declEvents)
		}
		
//		res.append("\n## Powers\n")
//		// compiling powers
//		for(i : 0..< model.powers.length) {
//			model.powers.get(i).compilePowers(i+1, res, declNames)
//		}
//		
//		res.append("\n## Surviving Obligations\n")
//		// compiling surviving obligations
//		for (i : 0..< model.sobligations.length) {
//			model.sobligations.get(i).compileSObligations(i+1, res, declNames)
//		}
		
		return res.toString
	}
	
//	def compileSObligations(Obligation obl, int i, StringBuilder res, HashMap<String, ArrayList<KeyValuePair>> declNames) {
//		res.append("SO(X)\t:-\tSO" + i + "(X).\n")
//		res.append("SO" + i + "(" + obl.name + ").\n")
//		res.append("associate(" + obl.name + ",cArgToCan).\n\n")
//		res.append("initially(debtor(X,P))\t:-\tO" + i + "(X),initially(bind(" + obl.role1 + ",P)).\n")
//		res.append("initially(creditor(X,P))\t:-\tO" + i + "(X),initially(bind(" + obl.role1 + ",P)).\n\n")
////		obl.antecedent.compileAntecedent(obl.name, res, declNames)
////		obl.trigger.compileTrigger(obl.name, res, declNames)
//		obl.consequent.compileOConsequent(obl.name, res, declNames)
//		res.append("\n\n")
//	}
//	
//	def compilePowers(Power power, int i, StringBuilder res, HashMap<String, ArrayList<KeyValuePair>> declNames) {
//		// this is probably just wrong (I do not think powers are handled the same as obligations)
//		res.append("P(X)\t:-\tP" + i + "(X).\n")
//		res.append("P" + i + "(" + power.name + ").\n")
//		res.append("associate(" + power.name + ",cArgToCan).\n\n")
//		res.append("initially(debtor(X,P))\t:-\tP" + i + "(X),initially(bind(" + power.role1 + ",P)).\n")
//		res.append("initially(creditor(X,P))\t:-\tP" + i + "(X),initially(bind(" + power.role1 + ",P)).\n\n")
////		power.antecedent.compileAntecedent(power.name, res, declNames)
////		power.trigger.compileTrigger(power.name, res, declNames)
//		power.consequent.compileOConsequent(power.name, res, declNames)
//	}
	
	/**
	 * checks the "root" type of each contract parameter and returns it
	 */
	def dispatch checkParameterType(DomainType dType, HashMap<String, String> superTypes) {
		var parentType = dType.superType.name
		
		while (superTypes.containsKey(parentType)) {
			parentType = superTypes.get(parentType)
		}
		
		return parentType
	}
	
	/**
	 * if a parameter is a basic type that type is returned as a string
	 */
	def dispatch checkParameterType(BasicType bType, HashMap<String, String> superTypes) {
		return bType.name
	}
	
	/**
	 * Generate prolog code for obligation
	 */
	def compileObligations(Obligation obl, int i, StringBuilder res, HashSet<String> declEvents) {
		res.append("O(X)\t:-\tO" + i + "(X).\n")
		res.append("O" + i + "(" + obl.name + ").\n")
		res.append("associate(" + obl.name + ",cArgToCan).\n\n")
		res.append("initially(debtor(X,P))\t:-\tO" + i + "(X),initially(bind(" + obl.role1 + ",P)).\n")
		res.append("initially(creditor(X,P))\t:-\tO" + i + "(X),initially(bind(" + obl.role1 + ",P)).\n\n")
//		obl.antecedent.compileAntecedent(obl.name, res, declNames)
//		obl.trigger.compileTrigger(obl.name, res, declNames)
		obl.consequent.compileOConsequent(obl.name, res, declEvents)
		res.append("\n\n")
	}
	
//	/**
//	 * Helper function to generate code for antecedent
//	 */
//	def compileAntecedent(Proposition prop, String oblName, StringBuilder res, HashMap<String, ArrayList<KeyValuePair>> declNames) {
//		var ant = new StringBuilder()
//		
//		ant.append("ant(" + oblName + ")\t:-\t")
//		for (i : 0..< prop.junctions.length) {
//			ant.append("(")
//			prop.junctions.get(i).obligationCompileAnds(ant, 0, oblName, declNames)
//			ant.append(")")
//			if (i < prop.junctions.length - 1) {
//				ant.append(" ; ")
//			}
//		}
//		ant.append(".\n")
//		
//		res.append(ant.toString)
//	}
	
	/**
	 * Helper function to generate code for consequent
	 */
	def compileOConsequent(Proposition prop, String oblName, StringBuilder res, HashSet<String> declEvents) {
		res.append("initiates(E0, cons(" + oblName + "))\t:-\t")
		prop.obligationCompileOrs(res, oblName, declEvents)
		res.append(".\n")
	}
	
//	def compileTrigger(Proposition trigger, String oblName, StringBuilder res, HashMap<String, ArrayList<KeyValuePair>> declNames) {
//		if (trigger == null) {
//			res.append("initiates(E0,trigger(" + oblName + "))\t:-\thappens(E0,_),initiates(E0,inEffect(cArgToCan)).\n")
//			return
//		}
//		
//		var trig = new StringBuilder()
//		trig.append("initiates(E0, trigger(" + oblName + "))\t:-\t")
//		for (i : 0..< trigger.junctions.length) {
//			trig.append("(")
//			trigger.junctions.get(i).obligationCompileAnds(trig, 0, oblName, declNames)
//			trig.append(")")
//			if (i < trigger.junctions.length - 1) {
//				trig.append(" ; ")
//			}
//		}
//		trig.append(".\n")
//		
//		res.append(trig.toString)
//	}

	/**
	 * Compiles the prolog code for all the ors in an and
	 * @param proposition (antecedent\consequent\trigger)
	 * @param res StringBuilder result
	 * @param oblName name of obligation
	 * @param declEvents HashSet containing the names of all declarations that are events
	 */
	def obligationCompileOrs(Proposition prop, StringBuilder res, String oblName, HashSet<String> declEvents) {
		var resProp = new StringBuilder()
		var events = new HashMap<String, String>() // maps value of event to some time number that it corresponds to
		var eventNumber = 0
		
		for (i : 0..< prop.junctions.length) {
			resProp.append("(")
			prop.junctions.get(i).obligationCompileAnds(resProp, eventNumber, oblName, declEvents, events)
			resProp.append(")")
			events.clear() // clear hashmap when moving to new or
			if (i < prop.junctions.length - 1) {
				resProp.append(" ; ")
			}	
		}
		
		res.append(resProp.toString)
	}
	
	def obligationCompileOrs(Proposition prop, StringBuilder res, int d, String oblName, HashSet<String> declEvents, HashMap<String, String> events) {
		var resProp = new StringBuilder()
		var eventNumber = d
		var mx = d 
		
		for (i : 0..< prop.junctions.length) {
			var eventsCopy = new HashMap<String,String>() // deep copy of input events
			for (key : events.keySet) {
				eventsCopy.put(key, events.get(key))
			}
			resProp.append("(")
			mx = Math.max(mx, prop.junctions.get(i).obligationCompileAnds(resProp, eventNumber, oblName, declEvents, eventsCopy))
			resProp.append(")")
			if (i < prop.junctions.length - 1) {
				resProp.append(" ; ")
			}
		}
		
		res.append(resProp.toString)
		return mx
	}
	
	/**
	 * Helper function to generate code for all ands in an or
	 * @param junction (part between OR of a proposition)
	 * @param res StringBuilder result
	 * @param d current event number
	 * @param oblName name of obligation
	 * @param declEvents HashSet containing the names of all declarations that are events
	 * @param events HashMap of all events that have been seen in this or as well as their corresponding event numbers
	 * 
	 * @return d the highest event numbering seen in the atom
	 */
	def int obligationCompileAnds(Junction or, StringBuilder res, int d, String oblName, HashSet<String> declEvents, HashMap<String, String> events) {
		var eventNumber = d
		for (i : 0..< or.negativeAtoms.length) {
			/**
			 * compile through each AND. throughout the process we keep counting from the previous d (ex. happens(E1, T1) AND happens(E2, T2)).
			 * Here, we maintain the events that have been seen.
			 */
			eventNumber = or.negativeAtoms.get(i).obligationCompileNegs(res, eventNumber, oblName, declEvents, events)
			if (i < or.negativeAtoms.length - 1) {
				res.append(',')
			}
		}
		
		return eventNumber
	}
	
	/**
	 * Helper function to generate code for negative atoms
	 * @param atom Negation Atomic unit in proposition (possibly negated)
	 * @param res StringBuilder result
	 * @param d next available event numbering
	 * @param oblName name of obligation
	 * @param declEvents HashSet containing the names of all declarations that are events
	 * @param events HashMap of all events that have been seen in this or as well as their corresponding event numbers
	 * 
	 * @return d the highest event numbering seen in the atom
	 */
	def obligationCompileNegs(Negation atom, StringBuilder res, int d, String oblName, HashSet<String> declEvents, HashMap<String, String> events) {
		var eventNumber = d
		if (atom.negated) {
			res.append("\\+(")
			eventNumber = atom.atomicExpression.obligationCompileAtom(res, eventNumber, oblName, declEvents, events)
			res.append(")")
		}
		else {
			eventNumber = atom.atomicExpression.obligationCompileAtom(res, eventNumber, oblName, declEvents, events)
		}
		
		return eventNumber
	}
	
	/**
	 * Helper function to generate code from an atom
	 * @param atom Atomic unit in proposition
	 * @param res StringBuilder result
	 * @param d next available event numbering
	 * @param oblName name of obligation
	 * @param declEvents HashSet containing the names of all declarations that are events
	 * @param events HashMap of all events that have been seen in this or as well as their corresponding event numbers
	 * 
	 * @return d the highest event numbering seen in the atom
	 */
	def obligationCompileAtom(Atom atom, StringBuilder res, int d, String oblName, HashSet<String> declEvents, HashMap<String, String> events) {
		var eventNumber = d
		if (atom.bool == 'TRUE') {
			res.append("TRUE")	
		}
		if (atom.bool == 'FALSE') {
			res.append("FALSE")
		}
		if (atom.eventProposition != null) {
			eventNumber = atom.eventProposition.obligationCompileEventProp(res, eventNumber, oblName, declEvents, events)
		}
		if (atom.inner != null) {
			eventNumber = atom.inner.obligationCompileOrs(res, eventNumber, oblName, declEvents, events)
		}
		if (atom.situationProposition != null) {
			eventNumber = atom.situationProposition.obligationCompileSituationProp(res, eventNumber, oblName, declEvents, events)
		}
//		if (atom.point != null && atom.interval != null) {
//			atom.point.obligationCompileWithin(atom.interval, res, d)
//		}

		return eventNumber
	}
	
//	def obligationCompileWithin(Point point, Interval interval, StringBuilder res, int d) {
//		point.compilePoint(res, d)
//		res.append(",")
//		interval.compileInterval(res, d+1)
//	}
	
	/**
	 * Helper function to generate code from an atom (happens function)
	 * @param eProp event and point 
	 * @param res StringBuilder result
	 * @param d next available event numbering
	 * @param oblName name of obligation
	 * @param declEvents HashSet containing the names of all declarations that are events
	 * @param events HashMap of all events that have been seen in this or as well as their corresponding event numbers
	 * 
	 * @return d the highest event numbering seen in the atom
	 */	
	def obligationCompileEventProp(EventProp eProp, StringBuilder res, int d, String oblName, HashSet<String> declEvents, HashMap<String, String> events) {
		var eventNumber = d
		var decl = new StringBuilder()
		
		// compile the event
		if (eProp.eventName != null) {
			// event is a declaration
			if (!events.containsKey(eProp.eventName.name)) {
				// if this was the first time the declaration was seen in this or we write these
				// and add the event to events and increment eventNumber
				res.append("within(E" + eventNumber + ",performer(E" + eventNumber + "," + oblName + ")),")
				res.append(eProp.eventName.name + "(E" + eventNumber + "),")
				events.put(eProp.eventName.name, eventNumber.toString)
				eventNumber += 1
			}
			var eNumber = events.get(eProp.eventName.name) // number corresponding to this event
			
			if (eProp.point.unnamed != null) {
				// event happens at an unspecified point
				res.append("happens(E" + eNumber + ",_)")
			}
			else if (eProp.point.tempOp != null) {
				// time point is a relative time
				if (eProp.point.eventName.declName != null) {
					// the time point referenced is also a declaration
					eventNumber = eProp.point.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
					
					res.append("happens(E" + eNumber + ",T" + events.get(eProp.point.eventName.declName))
				}
				else {
					// the time point referenced is a oEvent, cEvent or pEvent
					var eventString = new StringBuilder()
					eProp.point.eventName.compileEvent(eventString)
					eventNumber = eventString.toString.compileAddEvent(decl, eventNumber, oblName, events)
					res.append("happens(E" + eNumber + ",T" + events.get(eventString.toString))
				}
				
				// make the time relative based on the tempOp keyword
				eProp.point.tempOp.compileTempOp(res)
					
				res.append(eProp.point.pointConst.type + ")")
				res.append(decl.toString)
			}
			else if (eProp.point.eventName != null) {
				// time point is an event
				if (eProp.point.eventName.declName != null) {
					// the time point is also a declaration
					eventNumber = eProp.point.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)

					res.append("happens(E" + eNumber + ",T" + events.get(eProp.point.eventName.declName) + ")")
				}
				else {
					
					var eventString = new StringBuilder()
					eProp.point.eventName.compileEvent(eventString)
					eventNumber = eventString.toString.compileAddEvent(decl, eventNumber, oblName, events)
					res.append("happens(E" + eNumber + ",T" + events.get(eventString.toString) + ")")
				}
				
				res.append(decl.toString)
			}
			else {
				// time point is a constant
				res.append("happens(E" + eNumber + "," + eProp.point.pointConst.type + ")")
			}
		}
		else {
			res.append("happens(")
			if (eProp.OEventName != null) {
				eProp.OEventName.compileOEvent(res)
			}
			if (eProp.CEventName != null) {
				eProp.CEventName.compileCEvent(res)
			}
			if (eProp.PEventName != null) {
				eProp.PEventName.compilePEvent(res)
			}
			res.append(",")
			
			if (eProp.point.unnamed != null) {
				res.append("_")
			}
			else if (eProp.point.tempOp != null) {
				// time point is a relative time
				if (eProp.point.eventName.declName != null) {
					// the time point is a declaration
					eventNumber = eProp.point.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
					res.append("T" + events.get(eProp.point.eventName.declName))
				}
				else {
					// the time point is just an event
					var eventString = new StringBuilder()
					eProp.point.eventName.compileEvent(eventString)
					eventNumber = eventString.toString.compileAddEvent(decl, eventNumber, oblName, events)
					res.append("T" + events.get(eventString.toString))
				}
				
				// make the time relative based on the tempOp keyword
				eProp.point.tempOp.compileTempOp(res)
					
				res.append(eProp.point.pointConst.type)
			}
			else if (eProp.point.eventName != null) {
				// time point is an event
				if (eProp.point.eventName.declName != null) {
					// time point is also a declaration
					eventNumber = eProp.point.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
					
					res.append("T" + events.get(eProp.point.eventName.declName))
				}
				else {
					// the time point is just an event
					var eventString = new StringBuilder()
					eProp.point.eventName.compileEvent(eventString)
					eventNumber = eventString.toString.compileAddEvent(decl, eventNumber, oblName, events)
					res.append("T" + events.get(eventString.toString))
				}
			}
			else {
				// time point is a constant
				res.append(eProp.point.pointConst.type)
			}
			
			res.append(")")
			res.append(decl.toString)
		}
		
		return eventNumber
	}
	
	/**
	 * Helper function to generate code from an atom (occurs function)
	 * @param eProp situation and interval
	 * @param res StringBuilder result
	 * @param d next available event numbering
	 * @param oblName name of obligation
	 * @param declEvents HashSet containing the names of all declarations that are events
	 * @param events HashMap of all events that have been seen in this or as well as their corresponding event numbers
	 * 
	 * @return d the highest event numbering seen in the atom
	 */
	def obligationCompileSituationProp(SitProp sProp, StringBuilder res, int d, String oblName, HashSet<String> declEvents, HashMap<String, String> events) {
		var eventNumber = d
		var decl = new StringBuilder()
		
		//compile the situation
		if (sProp.situationName != null) {
			//situation is a declaration
		}
		else {
			res.append("occurs(")
			if (sProp.OSituationName != null) {
				sProp.OSituationName.compileOState(res)
			}
			if (sProp.CSituationName != null) {
				sProp.CSituationName.compileCState(res)
			}
			if (sProp.PSituationName != null) {
				sProp.PSituationName.compilePState(res)
			}
			res.append(",")
			// compile interval
			if (sProp.interval.unnamed != null) {
				// interval is unnamed
				res.append("_")
			}
			else if (sProp.interval.start != null && sProp.interval.end != null) {
				// interval is two points
				res.append("[")
				// compile start
				if (sProp.interval.start.unnamed != null) {
					res.append("_")
				}
				else if (sProp.interval.start.tempOp != null) {
					// start is a relative time
					if (sProp.interval.start.eventName.declName != null) {
						// relative time is a declaration
						eventNumber = sProp.interval.start.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
						
						var sNumber = events.get(sProp.interval.start.eventName.declName)
						res.append("T" + sNumber)
					}
					else {
						// relative time is just an event	
						var eventString = new StringBuilder()
						sProp.interval.start.eventName.compileEvent(eventString)
						eventNumber = eventString.toString.compileAddEvent(decl, eventNumber, oblName, events)
						res.append("T" + events.get(eventString.toString))
					}
					
					// make the time relative to the tempOp
					sProp.interval.start.tempOp.compileTempOp(res)
					res.append(sProp.interval.start.pointConst.type)
				}
				else if (sProp.interval.start.eventName != null) {
					// start is an event
					if (sProp.interval.start.eventName.declName != null) {
						// event is a declaration
						eventNumber = sProp.interval.start.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
						
						var sNumber = events.get(sProp.interval.start.eventName.declName)
						res.append("T" + sNumber)
					}
					else {
						// relative time is just an event	
						var eventString = new StringBuilder()
						sProp.interval.start.eventName.compileEvent(eventString)
						eventNumber = eventString.toString.compileAddEvent(decl, eventNumber, oblName, events)
						res.append("T" + events.get(eventString.toString))
					}
				}
				else {
					res.append(sProp.interval.start.pointConst.type)
				}
				
				res.append(",")
				
				// compile end
				if (sProp.interval.end.unnamed != null) {
					res.append("_")
				}
				else if (sProp.interval.end.tempOp != null) {
					// start is a relative time
					if (sProp.interval.end.eventName.declName != null) {
						// relative time is a declaration
						eventNumber = sProp.interval.end.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
						
						var eNumber = events.get(sProp.interval.end.eventName.declName)
						res.append("T" + eNumber)
					}
					else {
						// relative time is just an event	
						var eventString = new StringBuilder()
						sProp.interval.end.eventName.compileEvent(eventString)
						eventNumber = eventString.toString.compileAddEvent(decl, eventNumber, oblName, events)
						res.append("T" + events.get(eventString.toString))
					}
					
					// make the time relative to the tempOp
					sProp.interval.end.tempOp.compileTempOp(res)
					res.append(sProp.interval.end.pointConst.type)
				}
				else if (sProp.interval.end.eventName != null) {
					// start is an event
					if (sProp.interval.end.eventName.declName != null) {
						// event is a declaration
						eventNumber = sProp.interval.end.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
						
						var eNumber = events.get(sProp.interval.end.eventName.declName)
						res.append("T" + eNumber)
					}
					else {
						// relative time is just an event	
						var eventString = new StringBuilder()
						sProp.interval.end.eventName.compileEvent(eventString)
						eventNumber = eventString.toString.compileAddEvent(decl, eventNumber, oblName, events)
						res.append("T" + events.get(eventString.toString))
					}
				}
				else {
					res.append(sProp.interval.end.pointConst.type)
				}
				res.append("]")
			}
			else if (sProp.interval.situationName != null) {
				// the interval is a situation
				res.append("[")
				if (sProp.interval.situationName.declName != null) {
					// the situation is a declaration
					eventNumber = sProp.interval.situationName.declName.compileAddDeclSit(decl, eventNumber, oblName, events)
					res.append("T" + events.get(sProp.interval.situationName.declName))
					res.append(",")
					eventNumber = ("\\+" + sProp.interval.situationName.declName).compileAddDeclSit(decl, eventNumber, oblName, events)
					res.append("T" + events.get("\\+" + sProp.interval.situationName.declName))
				}
				else {
					// situation is oState, cState, pState
					var sitString = new StringBuilder()
					sProp.interval.situationName.compileState(sitString)
					eventNumber = sitString.toString.compileAddSit(decl, eventNumber, oblName, events)
					res.append("T" + events.get(sitString.toString))
					res.append(",")
					eventNumber = ("\\+" + sitString.toString).compileAddSit(decl, eventNumber, oblName, events)
					res.append("T" + events.get("\\+" + sitString.toString))
				}
				res.append("]")
			}
			else {
				// ????
			}
			res.append(")")
			res.append(decl.toString)
		}
		
		return eventNumber
	}
	
	/**
	 * Helper function to add declaration event to events and add's references to result
	 * @param declEvent String declaration name
	 * @param res StringBuilder result string
	 * @param d next available event numbering
	 * @param oblName name of obligation
	 * @param events HashMap mapping events to their event numbering
	 * 
	 * @return next available eventNumber
	 */
	def compileAddDeclEvent(String declEvent, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		
		if (!events.containsKey(declEvent)) {
			res.append(",within(E" + eventNumber + ",performer(E" + eventNumber + "," + oblName + ")),")
			res.append(declEvent + "(E" + eventNumber + "),")
			res.append("happens(E" + eventNumber + ",T" + eventNumber + ")")
			events.put(declEvent, eventNumber.toString)
			eventNumber += 1
		}
		
		return eventNumber
	}
	
	/**
	 * Helper function to add oEvent,cEvent,pEvent to events
	 * @param event String event name
	 * @param res StringBuilder result
	 * @param d next available event numbering
	 * @param oblName name of obligation
	 * @param events HashMap mapping events to their event numbering
	 * 
	 * @return next available eventNumber
	 */
	def compileAddEvent(String event, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		
		if (!events.containsKey(event)) {
			res.append(",happens(" + event + ",T" + eventNumber + ")")
			events.put(event, eventNumber.toString)
			eventNumber += 1
		}
		
		return eventNumber
	}
	
	/**
	 * Helper function to add oState,cState,pState to events
	 * @param situation String situation name
	 * @param res StringBuilder result
	 * @param d next available event numbering
	 * @param oblName name of obligation
	 * @param events HashMap mapping events to their event numbering
	 * 
	 * @return next available eventNumber
	 */
	def compileAddSit(String situation, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		
		if (!events.containsKey(situation)) {
			res.append(",initiates(E" + eventNumber + "," + situation + "),")
			res.append("happens(E" + eventNumber + ",T" + eventNumber + ")")
			events.put(situation, eventNumber.toString)
			eventNumber += 1
		}
		return eventNumber
	}
	
	/**
	 * Helper function to add situation declaration to events
	 * @param situation String situation name
	 * @param res StringBuilder result
	 * @param d next available event numbering
	 * @param oblName name of obligation
	 * @param events HashMap mapping events to their event numbering
	 * 
	 * @return next available eventNumber
	 */
	def compileAddDeclSit(String declSit, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		
		if (!events.containsKey(declSit)) {
			res.append(",initiates(E" + eventNumber + ",S" + eventNumber + "),")
			res.append("happens(E" + eventNumber + ",T" + eventNumber + "),")
			res.append(declSit + "(S" + eventNumber + ")")
			events.put(declSit, eventNumber.toString)
			eventNumber += 1
		}
		return eventNumber
	}
	
	/**
	 * Helper function to add operator to res
	 * @param tempOp String representing the operator
	 * @param res StringBuilder result string
	 */
	def compileTempOp(String TempOp, StringBuilder res) {
		switch (TempOp) {
			case 'BEFORE': res.append("-")
			case 'AFTER': res.append("+")
			case '+': res.append("+")
			case '-': res.append("-")	
		}
	}
	
	/**
	 * Helper function to determine what event a sitname is
	 * @param event SitName
	 * @param res StringBuilder result
	 */
	def compileEvent(SitName event, StringBuilder res) {
		if (event.OEvent != null) {
			event.OEvent.compileOEvent(res)
		}	
		if (event.CEvent != null) {
			event.CEvent.compileCEvent(res)
		}
		if (event.PEvent != null) {
			event.PEvent.compilePEvent(res)
		}
	}
	
	def compileOEvent(oEvent event, StringBuilder res) {
		switch (event.oblEvent) {
			case 'oTRIGGERED': res.append('trigger(' + event.oblName + ')')
			case 'oACTIVATED': res.append('activate(' + event.oblName + ')')
			case 'oSUSPENDED': res.append('suspend(' + event.oblName + ')')
			case 'oRESUMED': res.append('resume(' + event.oblName + ')')
			case 'oDISCHARGED': res.append('discharge(' + event.oblName + ')')
			case 'oEXPIRED': res.append('expire(' + event.oblName + ')')
			case 'oFULFILLED': res.append('fulfill(' + event.oblName + ')')
			case'oVIOLATED': res.append('violate(' + event.oblName + ')')
			case 'oTERMINATED': res.append('terminate(' + event.oblName + ')')
		}
	}
	
	def compileCEvent(cEvent event, StringBuilder res) {
		switch (event.contrEvent) {
			case 'cACTIVATED': res.append('activate(' + event.contrName + ')')
			case 'cSUSPENDED': res.append('suspend(' + event.contrName + ')')
			case 'cRESUMED': res.append('resume(' + event.contrName + ')')
			case 'cFULFILLED_ACTIVE_OBLS': res.append('fulfill(' + event.contrName + ')')
			case 'cREVOKED_PARTY': res.append('revoke(' + event.contrName + ')')
			case 'cASSIGNED_PARTY': res.append('assignParty(' + event.contrName + ')')
			case 'cTERMINATED': res.append('terminate(' + event.contrName + ')')
		}
	}
	
	def compilePEvent(pEvent event, StringBuilder res) {
		switch (event.powEvent) {
			case 'pTRIGGERED': res.append('trigger(' + event.powName + ')')
			case 'pACTIVATED': res.append('activate(' + event.powName + ')')
			case 'pSUSPENDED': res.append('suspend(' + event.powName + ')')
			case 'pRESUMED': res.append('resume(' + event.powName + ')')
			case 'pEXERTED': res.append('exert(' + event.powName + ')')
			case 'pEXPIRED': res.append('expire(' + event.powName + ')')
			case 'pTERMINATED': res.append('terminate(' + event.powName + ')')
		}
	}
	
	/**
	 * Helper function to determine what state a sitname is
	 * @param state SitName
	 * @param res StringBuilder result
	 */
	def compileState(SitName state, StringBuilder res) {
		if (state.OState != null) {
			state.OState.compileOState(res)
		}
		if (state.CState != null) {
			state.CState.compileCState(res)
		}
		if (state.PState != null) {
			state.PState.compilePState(res)
		}
	}
	
	def compileOState(oState state, StringBuilder res) {
		switch (state.oblState) {
			case 'oCREATE': res.append('create(' + state.oblName + ')')
			case 'oINEFFECT': res.append('ineffect(' + state.oblName + ')')
			case 'oSUSPENSION': res.append('suspension(' + state.oblName + ')')
			case 'oSUCCESSFUL_TERMINATION': res.append('successfulTermination(' + state.oblName + ')')
			case 'oUNSUCCESSFUL_TERMINATION': res.append('unsuccessfulTermination(' + state.oblName + ')')
			case 'oVIOLATION': res.append('violation(' + state.oblName + ')')
			case 'oFULFILLMENT': res.append('fulfillment(' + state.oblName + ')')
			case 'oDISCHARGE': res.append('discharge(' + state.oblName + ')')
		}
	}
	
	def compileCState(cState state, StringBuilder res) {
		switch (state.contrState) {
			case 'cFORM': res.append('form(' + state.contractName + ')')
			case 'cINEFFECT': res.append('ineffect(' + state.contractName + ')')
			case 'cSUSPENSION': res.append('suspension(' + state.contractName + ')')
			case 'cSUCCESSFUL_TERMINATION': res.append('successfulTermination(' + state.contractName + ')')
			case 'cUNSECCESSFUL_TERMINATION': res.append('unsuccessfulTermination(' + state.contractName + ')')
			case 'cUNASSIGN': res.append('unassign(' + state.contractName + ')')
		}
	}
	
	def compilePState(pState state, StringBuilder res) {
		switch (state.powState) {
			case 'pCREATE': res.append('create(' + state.powName + ')')
			case 'pINEFFECT': res.append('ineffect(' + state.powName + ')')
			case 'pSUSPENSION': res.append('suspension(' + state.powName + ')')
			case 'pSUCCESSFUL_TERMINATION': res.append('successfulTermination(' + state.powName + ')')
			case 'pUNSUCCESSFUL_TERMINATION': res.append('unsuccessfulTermination(' + state.powName + ')')
		}
	}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile('test.pl', resource.allContents.filter(Model).head.compile)
	}
}
