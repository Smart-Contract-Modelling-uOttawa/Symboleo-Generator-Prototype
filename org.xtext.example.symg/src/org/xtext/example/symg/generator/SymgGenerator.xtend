/*
 * generated by Xtext 2.22.0
 */
package org.xtext.example.symg.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.symg.symg.Model
import org.xtext.example.symg.symg.Obligation
import org.xtext.example.symg.symg.Proposition
import org.xtext.example.symg.symg.Junction
import org.xtext.example.symg.symg.Negation
import org.xtext.example.symg.symg.Atom
import org.xtext.example.symg.symg.EventProp
import org.xtext.example.symg.symg.SitProp
import org.xtext.example.symg.symg.oEvent
import org.xtext.example.symg.symg.cEvent
import org.xtext.example.symg.symg.pEvent
import org.xtext.example.symg.symg.oState
import org.xtext.example.symg.symg.cState
import org.xtext.example.symg.symg.pState
import org.xtext.example.symg.symg.SitName
import org.xtext.example.symg.symg.Point
import org.xtext.example.symg.symg.Power
import org.xtext.example.symg.symg.Interval
import java.util.HashMap
import org.xtext.example.symg.symg.Regular
import org.xtext.example.symg.symg.Enumeration
import org.xtext.example.symg.symg.DomainType
import org.xtext.example.symg.symg.BasicType
import org.xtext.example.symg.symg.OntoCType
import java.util.ArrayList
import java.util.HashSet
import org.xtext.example.symg.generator.KeyValuePair;
import java.lang.Math;
import org.xtext.example.symg.symg.RelativeEventPointBefore
import org.xtext.example.symg.symg.RelativeEventPointAfter
import org.xtext.example.symg.symg.RelativeSituationPointBefore
import org.xtext.example.symg.symg.RelativeSituationPointAfter

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SymgGenerator extends AbstractGenerator {
	//-----------------------------------------------------------------------//
	//-----------------------Domain Concept Generator------------------------//
	//-----------------------------------------------------------------------//
	
	/**
	 * Generates prolog code for a regular domain concept
	 */
	def dispatch compileDomainConcept(Regular domainConcept, StringBuilder res, HashMap<String, String> superTypes) {
		domainConcept.conceptType.compileCType(domainConcept.name, res, superTypes)
	}
	
	/**
	 * compiles domain concept if its type is another domain concept
	 */
	def dispatch compileCType(DomainType dType, String dName, StringBuilder res, HashMap<String, String> superTypes) {
		res.append(dType.superType.name + "(X)\t:-\t" + dName + "(X).\n")
		superTypes.put(dName, dType.superType.name)
	}
	
	/**
	 * compiles domain concept if its type is a basic type
	 */
	def dispatch compileCType(BasicType bType, String dName, StringBuilder res, HashMap<String, String> superTypes) {
		res.append(bType.name + "(" + dName + ").\n")
		superTypes.put(dName, bType.name)
	}
	
	/**
	 * compiles domain concept if its type is an ontoctype
	 */
	def dispatch compileCType(OntoCType oType, String dName, StringBuilder res, HashMap<String, String> superTypes) {
		if (oType.name.equals('ROLE')) {
			res.append("ROLE(" + dName + ").\n")
		}
		else {
			res.append(oType.name + "(X)\t:-\t" + dName + "(X).\n")
		}
		superTypes.put(dName, oType.name)
	}
	
	/**
	 * Generates prolog code for an enumeration domain concept
	 */
	def dispatch compileDomainConcept(Enumeration domainConcept, StringBuilder res, HashMap<String, String> superTypes) {
		for (value : domainConcept.enumerationItems) {
			res.append(domainConcept.name + "(" + value.name + ").\n")
		}
		res.append("\n")
	}
	
	//-----------------------------------------------------------------------//
	//-------------------------Declaration Generator-------------------------//
	//-----------------------------------------------------------------------//
	
		/**
	 * Writes the underscores for assets/roles/dates in contract binding
	 */
	def contractUnderscoreHelper(String contractName, int before, int after, StringBuilder res) {
		res.append("initially(" + contractName + "(")
		for (i : 0..< before) {
			res.append("_,")
		}
		res.append("X")
		for (i : 0..< after) {
			res.append(",_")
		}
		res.append(")).\n")
	}
	
	/**
	 * Generates prolog code for declarations
	 */
	def compileDeclaration(String parent, String declName, StringBuilder res, HashMap<String, ArrayList<KeyValuePair>> declAttrs, HashSet<String> dates) {
		var i = 0
		for (attr: declAttrs.get(declName)) {

			if (declAttrs.containsKey(attr.value)) {
				// the value of this attribute is a declaration
				attr.value.compileDeclarations(res, declAttrs, dates)
			}
			// if the value is date in the parameters, ignore it
			if (!dates.contains(attr.value)) {
				res.append("holds_at(" + attr.key + "(" + parent + "," + attr.value + "),T)")	
				if (i < declAttrs.get(declName).length - 1) {
					res.append(",")
				}
			}
			i += 1
		}
	}
	
	/**
	 * Recursively generates prolog code for declaration attributes that are also declarations
	 */
	def compileDeclarations(String object, StringBuilder res, HashMap<String, ArrayList<KeyValuePair>> declAttrs, HashSet<String> dates) {
		for (attr: declAttrs.get(object)) {

			if (declAttrs.containsKey(attr.value)) {
				// the value of this attribute is a declaration
				attr.value.compileDeclarations(res, declAttrs, dates)
			}
			// if the value is date in the parameters, ignore it 
			if (!dates.contains(attr.value)) {
				res.append("holds_at(" + attr.key + "(" + object + "," + attr.value + "),T),")	
			}
		}
	}
	
	def compile(Model model) {
		var res = new StringBuilder()
		var superTypes = new HashMap<String, String>()
		var declAttrs = new HashMap<String, ArrayList<KeyValuePair>>()
		var declEvents = new HashSet<String>()
		var dates = new HashSet<String>()
		var roles = new HashSet<String>()
		var assets = new HashSet<String>()
		var underscoreAfter = model.parameters.length + 1
		var underscoreBefore = 0
		
		// compiling domain
		res.append("## Domain\n")
		for (domainConcept : model.domainConcepts) {
			domainConcept.compileDomainConcept(res, superTypes)
		}
			
		// count the number of contract parameters
		for (param: model.parameters) {
			var pType = param.type.checkParameterType(superTypes)
			if (pType.equals('ROLE') || pType.equals('DATE')) {
				if (pType.equals('ROLE')) {
					// add parameter name to roles
					roles.add(param.name)
				}
				if (pType.equals('DATE')) {
					// add parameter name to dates
					dates.add(param.name)
				}
				
			}
		}
		
		// count the number of contract parameters
		// map attributes/attribute values to the names of declarations
		// let's just consider that assets will always be formed in declarations from basic types
		for (declaration : model.declarations) {
			var parentType = declaration.type.name
			var attrs = new ArrayList<KeyValuePair>()
			
			while (superTypes.containsKey(parentType)) {
				parentType = superTypes.get(parentType)
			}
			
			if (parentType.equals('ASSET')) {
				assets.add(declaration.name)
			}
			if (parentType.equals('EVENT')) {
				// keeps track of all declarations that are events
				declEvents.add(declaration.name)
			}
			
			// adding pair value pairs of each declaration attribute to arr list
			for (attribute: declaration.attributes) {
				attrs.add(new KeyValuePair(attribute.attr, attribute.param))
			}
			
			declAttrs.put(declaration.name, attrs)
		}
		
		// initialize contract
		res.append("\n## Contract\n")	
		res.append("c(X)\t:-\t")
		contractUnderscoreHelper(model.contractName, underscoreBefore, underscoreAfter, res)
		res.append("\n")
		underscoreAfter -= 1
		underscoreBefore += 1
		
		for (role : roles) {
			res.append("initially(bind(" + role + ",X))\t:-\t")
			contractUnderscoreHelper(model.contractName, underscoreBefore, underscoreAfter, res)
			underscoreAfter -= 1
			underscoreBefore += 1
		}
		
		for (param : model.parameters) {
			if (!roles.contains(param.name)) {
				res.append(param.name + "(X)\t:-\t")
				contractUnderscoreHelper(model.contractName, underscoreBefore, underscoreAfter, res)
				underscoreAfter -= 1
				underscoreBefore += 1	
			}
		}
		
		res.append("initially(form(X))\t:-\t")
		contractUnderscoreHelper(model.contractName, underscoreBefore-1, underscoreAfter, res)
		
		// initialize declarations
		res.append("\n## Declarations\n")
		// compile declaration events
		for (d : declAttrs.keySet) {
			if (declEvents.contains(d)) {
				res.append(d + "(E)\t:-\t")
				res.append("happens(E,T),holds_at(type(E," + d + ")),")
				"E".compileDeclaration(d, res, declAttrs, dates)		
				res.append(".\n")
			}
		}
		
		res.append("\n## Obligations\n")
		// compiling obligations
		for (i : 0 ..< model.obligations.length) {
			model.obligations.get(i).compileObligations(i+1, res)
		}
		
		res.append("\n## Powers\n")
		// compiling powers
		for (i : 0 ..< model.powers.length) {
			model.powers.get(i).compilePowers(i+1, res)	
		}	
			
		res.append("\n## Surviving Obligations\n")
		// compiling surviving obligations
		for (i : 0..< model.sobligations.length) {
			model.sobligations.get(i).compileSObligations(i+1, res)
		}
		
		return res.toString
	}
	
	/**
	 * checks the "root" type of each contract parameter and returns it
	 */
	def dispatch checkParameterType(DomainType dType, HashMap<String, String> superTypes) {
		var parentType = dType.superType.name
		
		while (superTypes.containsKey(parentType)) {
			parentType = superTypes.get(parentType)
		}
		
		return parentType
	}
	
	/**
	 * if a parameter is a basic type that type is returned as a string
	 */
	def dispatch checkParameterType(BasicType bType, HashMap<String, String> superTypes) {
		return bType.name
	}
	
	//-----------------------------------------------------------------------//
	//-------------------------Obligation Generator--------------------------//
	//-----------------------------------------------------------------------//
	
	/**
	 * Generate prolog code for obligation
	 * 
	 * @param Obligation obl obligation object
	 * @param int i obligation number
	 * @param StringBuilder res StringBuilder containing the result string
	 */
	def compileObligations(Obligation obl, int i, StringBuilder res) {
		res.append("O(X)\t:-\tO" + i + "(X).\n")
		res.append("O" + i + "(" + obl.name + ").\n")
		res.append("associate(" + obl.name + ",cArgToCan).\n\n")
		res.append("initially(debtor(X,P))\t:-\tO" + i + "(X),initially(bind(" + obl.role1 + ",P)).\n")
		res.append("initially(creditor(X,P))\t:-\tO" + i + "(X),initially(bind(" + obl.role2 + ",P)).\n\n")
		obl.antecedent.compileOAntecedent(obl.name, res)
		obl.trigger.compileTrigger(obl.name, res)
		obl.consequent.compileOConsequent(obl.name, res)
		res.append("\n\n")
	}
	
	/**
	 * Helper function to generate code for antecedent
	 */
	def compileOAntecedent(Proposition prop, String oblName, StringBuilder res) {
		res.append("ant(" + oblName + ")\t:-\t")
		prop.obligationCompileOrs(res, oblName)
		res.append(".\n")
	}
	
	/**
	 * Helper function to generate code for consequent
	 */
	def compileOConsequent(Proposition prop, String oblName, StringBuilder res) {
		res.append("initiates(E0, cons(" + oblName + "))\t:-\t")
		prop.obligationCompileOrs(res, oblName)
		res.append(".\n")
	}
	
	/**
	 * Helper function to generate code for trigger
	 */
	def compileTrigger(Proposition prop, String oblName, StringBuilder res) {
	 	res.append("initiates(E0, trigger(" + oblName + "))\t:-\t")
	 	if (prop != null) {
	 		prop.obligationCompileOrs(res, oblName)
	 	}
	 	else {
	 		res.append("happens(E0,_),initiates(E0,inEffect(cArgToCan))")
	 	}
	 	res.append(".\n")
	 }
	 
	 /**
	  * Compiles the ORs in a composite proposition and add's the returned string to res
	  * 
	  * @param Proposition prop a composite of atoms connected by ANDS
	  * @param StringBuilder res StringBuilder containing result string
	  * @param String oblName name of parent obligation
	  */
	def obligationCompileOrs(Proposition prop, StringBuilder res, String oblName) {
		var resProp = new StringBuilder()
		var events = new HashMap<String, String>() // maps value of event to some time number that it corresponds to
		var eventNumber = 0
		
		for (i : 0..< prop.junctions.length) {
			resProp.append("(")
			prop.junctions.get(i).obligationCompileAnds(resProp, eventNumber, oblName, events)
			resProp.append(")")
			events.clear() // clear hashmap when moving to new or
			if (i < prop.junctions.length - 1) {
				resProp.append(" ; ")
			}	
		}
		
		res.append(resProp.toString)
	}
	
	/**
	 * Recursive function for ORs in case one of the atoms was a nested proposition (we would then need to compile all the ORS in that proposition)
	 * 
	  * @param Proposition prop a composite of atoms connected by ANDS
	  * @param StringBuilder res StringBuilder containing result string
	  * @param int d next available numbering for events
	  * @param String oblName name of parent obligation
	  * @param HashMap<String,String> events hashmap mapping events to an event number
	  * 
	  * @return max numbering of events in ORs
	 */
	def obligationCompileOrs(Proposition prop, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var resProp = new StringBuilder()
		var eventNumber = d
		var mx = d 
		
		for (i : 0..< prop.junctions.length) {
			var eventsCopy = new HashMap<String,String>() // deep copy of input events
			for (key : events.keySet) {
				eventsCopy.put(key, events.get(key))
			}
			resProp.append("(")
			mx = Math.max(mx, prop.junctions.get(i).obligationCompileAnds(resProp, eventNumber, oblName, eventsCopy))
			resProp.append(")")
			if (i < prop.junctions.length - 1) {
				resProp.append(" ; ")
			}
		}
		
		res.append(resProp.toString)
		return mx
	}
	
	/**
	 * Compiles the ANDs in the composite junction and add's the returned string to res
	 * 
	 * @param Junction or a junction in the proposition (is a composite of atoms connected by ANDs)
	 * @param StringBuilder res StringBuilder containing result string
	 * @param int d next available numbering for events
	 * @param String oblName name of parent obligation
	 * @param HashMap<String,String> events hashmap mapping events to an event number
	 * 
	 * @return next available numbering for event
	 */
	def int obligationCompileAnds(Junction or, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		for (i : 0..< or.negativeAtoms.length) {
			/**
			 * compile through each AND. throughout the process we keep counting from the previous d (ex. happens(E1, T1) AND happens(E2, T2)).
			 * Here, we maintain the events that have been seen.
			 */
			eventNumber = or.negativeAtoms.get(i).obligationCompileNegs(res, eventNumber, oblName, events)
			if (i < or.negativeAtoms.length - 1) {
				res.append(',')
			}
		}
		
		return eventNumber
	}
	
	/**
	 * Compiles the atom (possibly negated) and add's the returned string to res
	 * 
	 * @param Negation atom atom that is possibly negated
	 * @param StringBuilder res StringBuilder containing result string
	 * @param int d next available numbering for events
	 * @param String oblName name of parent obligation
	 * @param HashMap<String,String> events hashmap mapping events to an event number
	 * 
	 * @return next available numbering for event
	 */
	def obligationCompileNegs(Negation atom, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		if (atom.negated) {
			res.append("\\+(")
			eventNumber = atom.atomicExpression.obligationCompileAtom(res, eventNumber, oblName, events)
			res.append(")")
		}
		else {
			eventNumber = atom.atomicExpression.obligationCompileAtom(res, eventNumber, oblName, events)
		}
		
		return eventNumber
	}
	
	/**
	 * Compiles the atom and add's the returned string to res
	 * 
	 * @param Atom atom atomic expression
	 * @param StringBuilder res StringBuilder containing result string
	 * @param int d next available numbering for events
	 * @param String oblName name of parent obligation
	 * @param HashMap<String,String> events hashmap mapping events to an event number
	 * 
	 * @return next available numbering for event
	 */
	def obligationCompileAtom(Atom atom, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		if (atom.bool == 'TRUE') {
			res.append("TRUE")	
		}
		if (atom.bool == 'FALSE') {
			res.append("FALSE")
		}
		
		if (atom.eventProposition != null) {
			eventNumber = atom.eventProposition.obligationCompileEventProp(res, eventNumber, oblName, events)
		}
		if (atom.inner != null) {
			eventNumber = atom.inner.obligationCompileOrs(res, eventNumber, oblName, events)
		}
		if (atom.situationProposition != null) {
			eventNumber = atom.situationProposition.obligationCompileSituationProp(res, eventNumber, oblName, events)
		}
		if (atom.point != null && atom.interval != null) {
			eventNumber = atom.point.obligationCompilePointInInterval(atom.interval, res, eventNumber, oblName, events)
		}

		return eventNumber
	}
	
	/**
	 * Compiles the atom (happens event)
	 * 
	 * @param EventProp eProp event and time pair
	 * @param StringBuilder res StringBuilder containing result string
	 * @param int d next available numbering for events
	 * @param String oblName name of parent obligation
	 * @param HashMap<String,String> events hashmap mapping events to an event number
	 * 
	 * @return next available numbering for event
	 */
	def obligationCompileEventProp(EventProp eProp, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		var decl = new StringBuilder()
		
		res.append("happens(")
		if (eProp.eventName != null) {
			// event is a declaration
			if (!events.containsKey(eProp.eventName.name)) {
				decl.append(",within(E" + eventNumber + ",performer(E" + eventNumber + "," + oblName + ")),")
				decl.append(eProp.eventName.name + "(E" + eventNumber + ")")
				events.put(eProp.eventName.name, eventNumber.toString)
				eventNumber += 1
			}
			res.append("E" + events.get(eProp.eventName.name))
		}
		else {
			if (eProp.OEventName != null) {
				res.append(eProp.OEventName.compileOEvent)
			}
			if (eProp.CEventName != null) {
				res.append(eProp.CEventName.compileCEvent)
			}
			if (eProp.PEventName != null) {
				res.append(eProp.PEventName.compilePEvent)
			}
		}
		res.append(",")
		eventNumber = eProp.point.compilePoint(res, decl, eventNumber, oblName, events)
		res.append(")")
		res.append(decl.toString)
		return eventNumber
	}
	
	/**
	 * Helper function to compile a point in time
	 */
	def compilePoint(Point point, StringBuilder res, StringBuilder decl, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		
		if (point.unnamed != null) {
			res.append("_")
		}
		else if (point.eventName != null && point.pointConst == null) {
			if (point.eventName.declName != null) {
				eventNumber = point.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
				res.append("T" + events.get(point.eventName.declName))
			}
			else {
				eventNumber = point.eventName.compileEvent.compileAddEvent(decl, eventNumber, oblName, events)
				res.append("T" + events.get(point.eventName.compileEvent))
			}
		}
		else if (point.eventName == null && point.pointConst != null){
			res.append(point.pointConst.type)
		}
		else {
			eventNumber = point.compileRelativePointTime(res, decl, eventNumber, oblName, events)
		}
		
		return eventNumber	
	}
	
	def dispatch compileRelativePointTime(RelativeEventPointBefore point, StringBuilder res, StringBuilder decl, int d, String oblName, HashMap<String,String> events) {
		var eventNumber = d
		
		if (point.eventName.declName != null) {
			eventNumber = point.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
			res.append("T" + events.get(point.eventName.declName))
		}
		else {
			eventNumber = point.eventName.declName.compileAddEvent(decl, eventNumber, oblName, events)
			res.append("T" + events.get(point.eventName.compileEvent))
		}
		
		res.append(point.tempOp.compileTempOpB + point.pointConst.type)
		
		return eventNumber
	}
	
	def dispatch compileRelativePointTime(RelativeEventPointAfter point, StringBuilder res, StringBuilder decl, int d, String oblName, HashMap<String,String> events) {
		var eventNumber = d
		
		if (point.eventName.declName != null) {
			eventNumber = point.eventName.declName.compileAddDeclEvent(decl, eventNumber, oblName, events)
			res.append("T" + events.get(point.eventName.declName))
		}
		else {
			eventNumber = point.eventName.declName.compileAddEvent(decl, eventNumber, oblName, events)
			res.append("T" + events.get(point.eventName.compileEvent))
		}
		
		res.append(point.tempOp.compileTempOpA + point.pointConst.type)
		
		return eventNumber
	}
	
	/**
	 * Compiles the atom (occurs)
	 * 
	 * @param SitProp sProp situation and interval pair
	 * @param StringBuilder res StringBuilder containing result string
	 * @param int d next available numbering for events
	 * @param String oblName name of parent obligation
	 * @param HashMap<String,String> events hashmap mapping events to an event number
	 * 
	 * @return next available numbering for event
	 */
	def obligationCompileSituationProp(SitProp sProp, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		var decl = new StringBuilder()
		
		//compile the situation
		res.append("occurs(")
		if (sProp.situationName != null) {
			//situation is a declaration
			eventNumber = sProp.situationName.compileAddDeclSit(decl,eventNumber, oblName, events)
			res.append("S" + events.get(sProp.situationName))
		}
		else {
			if (sProp.OSituationName != null) {
				res.append(sProp.OSituationName.compileOState)
			}
			if (sProp.CSituationName != null) {
				res.append(sProp.CSituationName.compileCState)
			}
			if (sProp.PSituationName != null) {
				res.append(sProp.PSituationName.compilePState)
			}
		}
		res.append(",")
		
		// compile interval
		if (sProp.interval.unnamed != null) {
			// interval is unnamed
			res.append("_)")
		}
		else {
			res.append("[")
			if (sProp.interval.start != null && sProp.interval.end != null) {
				// interval is two points
				var start = new StringBuilder()
				var end = new StringBuilder()
				// compile start
				eventNumber = sProp.interval.start.compilePoint(res, decl, eventNumber, oblName, events)
				sProp.interval.start.compilePoint(start, decl, eventNumber, oblName, events)				
				res.append(",")
				// compile end
				eventNumber = sProp.interval.end.compilePoint(res, decl, eventNumber, oblName, events)
				sProp.interval.end.compilePoint(end, decl, eventNumber, oblName, events)
				res.append("]),")
				
				// if neither point is null then start is before end
				if (start.toString != "_" && end.toString != "_") {
					res.append(start.toString + "<=" + end.toString)
				}
			}
			else if (sProp.interval.situationName != null && sProp.interval.intConst == null) {
				if (sProp.interval.situationName.declName != null) {
					eventNumber = sProp.interval.situationName.declName.compileAddDeclSit(decl, eventNumber, oblName, events)
					res.append("T" + events.get(sProp.interval.situationName.declName))
				}
				else {
					eventNumber = sProp.interval.situationName.compileState.compileAddSit(decl, eventNumber, oblName, events)
					res.append("T" + events.get(sProp.interval.situationName.compileState))
				}
				res.append(",_])")
			}
			else {

				res.append("[")
				eventNumber = sProp.interval.compileRelativeSituation(res, decl, eventNumber, oblName, events)
				res.append(",_]),")
			}
			
		}
			
		res.append(decl.toString)
			
		return eventNumber
	}
	
	def dispatch compileRelativeSituation(RelativeSituationPointBefore situation, StringBuilder res, StringBuilder decl, int d, String oblName, HashMap<String,String> events) {
		var eventNumber = d
		
		if (situation.situationName.declName != null) {
			eventNumber = situation.situationName.declName.compileAddDeclSit(decl, eventNumber, oblName, events)
			res.append("T" + events.get(situation.situationName.declName))
		}
		else {
			eventNumber = situation.situationName.compileState.compileAddSit(decl, eventNumber, oblName, events)
			res.append("T" + events.get(situation.situationName.compileState))
		}
		
		res.append(situation.tempOp.compileTempOpB + situation.intConst.type)
		return eventNumber
	}
	
	def dispatch compileRelativeSituation(RelativeSituationPointAfter situation, StringBuilder res, StringBuilder decl, int d, String oblName, HashMap<String,String> events) {
		var eventNumber = d
		
		if (situation.situationName.declName != null) {
			eventNumber = situation.situationName.declName.compileAddDeclSit(decl, eventNumber, oblName, events)
			res.append("T" + events.get(situation.situationName.declName))
		}
		else {
			eventNumber = situation.situationName.compileState.compileAddSit(decl, eventNumber, oblName, events)
			res.append("T" + events.get(situation.situationName.compileState))
		}
		
		res.append(situation.tempOp.compileTempOpA + situation.intConst.type)
		
		return eventNumber	
	}
	
	/**
	 * Compiles the atom (point within interval)
	 * 
	 * @param Point point point in time
	 * @param Interval interval interval in time
	 * @param StringBuilder res StringBuilder containing result string
	 * @param int d next available numbering for events
	 * @param String oblName name of parent obligation
	 * @param HashMap<String,String> events hashmap mapping events to an event number
	 * 
	 * @return next available numbering for event
	 */
	def obligationCompilePointInInterval(Point point, Interval interval, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		var decl = new StringBuilder()
		var time = new StringBuilder()
		var start = new StringBuilder()
		var end = new StringBuilder()
		
		// compile point
		eventNumber = point.compilePoint(time, decl, eventNumber, oblName, events)
		
		// compile interval
		if (interval.unnamed != null) {
			// I think this should be invalid
		}
		else {
			if (interval.start != null && interval.end != null) {
				// interval is two points
				// compile start
				eventNumber = interval.start.compilePoint(start, decl, eventNumber, oblName, events)
				// compile end
				eventNumber = interval.end.compilePoint(end, decl, eventNumber, oblName, events)
			}
			else if (interval.situationName != null && interval.intConst == null) {
				if (interval.situationName.declName != null) {
					eventNumber = interval.situationName.declName.compileAddDeclSit(decl, eventNumber, oblName, events)
					start.append("T" + events.get(interval.situationName.declName))
				}
				else {
					eventNumber = interval.situationName.compileState.compileAddSit(decl, eventNumber, oblName, events)
					start.append("T" + events.get(interval.situationName.compileState))
				}
			}
			else {
				eventNumber = interval.compileRelativeSituation(start, decl, eventNumber, oblName, events)
			}
			
			// ensure that start <= point <= end times
			if (start.toString != "_" && start.toString != "") {
				res.append(start.toString + "<=" + time.toString)
			}
			if (start.toString != "_" && end.toString != "_" && start.toString != "" && end.toString != "") {
				res.append(",")
			}
			if (end.toString != "_" && end.toString != "") {
				res.append(time.toString + "<=" + end.toString)
			}
		}
		
		res.append(decl.toString)
		return eventNumber
	}
	
	//-----------------------------------------------------------------------//
	//-------------------Surviving Obligation Generator----------------------//
	//-----------------------------------------------------------------------//
	
	/**
	 * Generates prolog code for Surviving Obligations
	 * 
	 * @param Obligation obl surviving obligation
	 * @param int i obligation number
	 * @param StringBuilder res StringBuilder containing the result string
	 */
	def compileSObligations(Obligation obl, int i, StringBuilder res) {
		res.append("SO(X)\t:-\tSO" + i + "(X).\n")
		res.append("SO" + i + "(" + obl.name + ").\n")
		res.append("associate(" + obl.name + ",cArgToCan).\n\n")
		res.append("initially(debtor(X,P))\t:-\tSO" + i + "(X),initially(bind(" + obl.role1 + ",P)).\n")
		res.append("initially(creditor(X,P))\t:-\tSO" + i + "(X),initially(bind(" + obl.role2 + ",P)).\n\n")
		obl.antecedent.compileOAntecedent(obl.name, res)
		obl.trigger.compileTrigger(obl.name, res)
		obl.consequent.compileOConsequent(obl.name, res)
		res.append("\n\n")
	}
	
	//-----------------------------------------------------------------------//
	//---------------------------Power Generator-----------------------------//
	//-----------------------------------------------------------------------//
	
	/**
	 * Generates prolog code for Powers
	 * 
	 * @param Power pow Power
	 * @param int i power number
	 * @param StringBuilder res StringBuilder containing the result string
	 */
	def compilePowers(Power pow, int i, StringBuilder res) {
		res.append("P(X)\t:-\tP" + i + "(X).\n")
		res.append("P" + i + "(" + pow.name + ").\n")
		res.append("associate(" + pow.name + ",cArgToCan).\n\n")
		res.append("initially(debtor(X,P))\t:-\tP" + i + "(X),initially(bind(" + pow.role1 + ",P)).\n")
		res.append("initially(creditor(X,P))\t:-\tP" + i + "(X),initially(bind(" + pow.role2 + ",P)).\n\n")
		pow.antecedent.compileOAntecedent(pow.name, res)
		pow.trigger.compileTrigger(pow.name, res)
		pow.consequent.compilePConsequent(pow.name, res)
		res.append("\n\n")
	}
	
	/**
	 * Helper function to generate code for power consequent
	 */
	def compilePConsequent(Proposition prop, String powName, StringBuilder res) {
		prop.powerCompileStates(res, powName)
		
		res.append("happens(exerted(" + powName + "), T0))\t:-\t")
		prop.powerCompileOrs(res, powName)
		res.append(".\n")
	}
	
	/**
	 * Helper function to find all states within atoms
	 */
	def powerCompileStates(Proposition prop, StringBuilder res, String powName) {
		 for (or : prop.junctions) {
		 	or.powerCompileStates(res, powName)
		 }
	}
	
	/**
	 * Helper function to find all states within atoms
	 */
	def powerCompileStates(Junction or, StringBuilder res, String powName) {
		 for (and : or.negativeAtoms) {
		 	and.powerCompileStates(res, powName)
		 }
	}
	
	/**
	 * Helper function to find all states within atoms
	 */
	def powerCompileStates(Negation neg, StringBuilder res, String powName) {
		neg.atomicExpression.powerCompileStates(res, powName)
	}
	
	/**
	 * Helper function to find all states within atoms
	 */
	def powerCompileStates(Atom atom, StringBuilder res, String powName) {
		if (atom.situationProposition != null) {
			if (atom.situationProposition.CSituationName != null) {
				res.append(atom.situationProposition.CSituationName.compileCState + "(cArgToCan)")
			}
			else if (atom.situationProposition.OSituationName != null) {
				res.append(atom.situationProposition.OSituationName.compileOState + "(" + atom.situationProposition.OSituationName.oblName + ")")
			}
			else if (atom.situationProposition.PSituationName != null) {
				res.append(atom.situationProposition.PSituationName.compilePState + "(" + atom.situationProposition.PSituationName.powName + ")")
			}
			res.append("\t:-\tcons(" + powName + ").\n")
		}
	}
	
	def powerCompileOrs(Proposition prop, StringBuilder res, String powName) {
		var resProp = new StringBuilder()
		var events = new HashMap<String, String>()
		var eventNumber = 0
		
		for (i : 0..< prop.junctions.length) {
			resProp.append("(")
			prop.junctions.get(i).powerCompileAnds(resProp, eventNumber, powName, events)
			resProp.append(")")
			if (i < prop.junctions.length - 1) {
				resProp.append(" ; ")
			}
			events.clear() // clear hashmap when moving to new or
		}
		
		res.append(resProp.toString)
	}
	
	def powerCompileAnds(Junction or, StringBuilder res, int d, String powName, HashMap<String, String> events) {
		var eventNumber = d
		for (i : 0..< or.negativeAtoms.length) {
			eventNumber = or.negativeAtoms.get(i).powerCompileNegs(res, eventNumber, powName, events)
			if (i < or.negativeAtoms.length - 1) {
				res.append(',')
			}
		}
		return eventNumber
	}
	
	def powerCompileNegs(Negation atom, StringBuilder res, int d, String powName, HashMap<String, String> events) {
		var eventNumber = d
		if (atom.negated) {
			res.append("\\+(")
			eventNumber = atom.atomicExpression.powerCompileAtom(res, eventNumber, powName, events)
			res.append(")")
		}
		else {
			eventNumber = atom.atomicExpression.powerCompileAtom(res, eventNumber, powName, events)
		}
		return eventNumber
	}
	
	def powerCompileAtom(Atom atom, StringBuilder res, int d, String powName, HashMap<String, String> events) {
		var eventNumber = d
		if (atom.bool == 'TRUE') {
			res.append("TRUE")
		}
		if (atom.bool == 'FALSE') {
			res.append("FALSE")
		}
		
		if (atom.eventProposition != null) {
			eventNumber = atom.eventProposition.obligationCompileEventProp(res, eventNumber, powName, events)
		}
		if (atom.situationProposition != null) {
			eventNumber = atom.situationProposition.powerCompileSituationProp(res, eventNumber, powName, events)
		}
		
		return eventNumber
	}
	
	def powerCompileSituationProp(SitProp sProp, StringBuilder res, int d, String powName, HashMap<String, String> events) {
		var eventNumber = d
		var decl = new StringBuilder()
		var String[] causes
		
		//find the event that creates the situation
		if (sProp.situationName != null) {
			//situation is a declaration
		}
		else {
			// compile situation
			if (sProp.OSituationName != null) {
				causes = sProp.OSituationName.mapOStateToEvent.split(",")
			}
			if (sProp.CSituationName != null) {
				causes = sProp.CSituationName.mapCStateToEvent.split(",")
			}
			if (sProp.PSituationName != null) {
				causes = sProp.PSituationName.mapPStateToEvent.split(",")
			}
			
			// compile interval
			if (sProp.interval.unnamed != null) {
				res.append("(")
				for (i : 0..< causes.length) {
					res.append("happens(" + causes.get(i) + ",_)")
					if (i < causes.length - 1) {
						res.append(" ; ")
					}
				}
				res.append(")")
			}
			else {
				if (sProp.interval.start != null && sProp.interval.end != null) {
					var start = new StringBuilder()
					var end = new StringBuilder()
					
					eventNumber = sProp.interval.start.compilePoint(start, decl, eventNumber, powName, events)
					eventNumber = sProp.interval.end.compilePoint(end, decl, eventNumber, powName, events)
					
					res.append("(")
					for (i : 0..< causes.length) {
						if (!events.containsKey(causes.get(i))) {
							events.put(causes.get(i), eventNumber.toString)
						}
						res.append("happens(" + causes.get(i) + ",T" + events.get(causes.get(i)) + ")")
						if (i < causes.length - 1) {
							res.append(" ; ")
						}
					}
					res.append("),")
					res.append(start.toString + "<=T" + eventNumber + "<=" + end.toString)
					eventNumber += 1
				}
				else {
					if (sProp.interval.situationName != null) {
						eventNumber = sProp.interval.situationName.declName.compileAddDeclSit(decl, eventNumber, powName, events)
						res.append("(")
						for (i : 0..< causes.length) {
							if (!events.containsKey(causes.get(i))) {
								events.put(causes.get(i), eventNumber.toString)
							}
							res.append("happens(" + causes.get(i) + ",T" + events.get(causes.get(i)))
							res.append(")")
							if (i < causes.length - 1) {
								res.append(" ; ")
							}
						}
						res.append("),")
						res.append("T" + events.get(sProp.interval.situationName.declName))
						res.append("<=T" + eventNumber)
						eventNumber += 1
					}
					else {
						eventNumber = sProp.interval.situationName.compileState.compileAddSit(decl, eventNumber, powName, events)
						res.append("(")
						for (i : 0..< causes.length) {
							if (!events.containsKey(causes.get(i))) {
								events.put(causes.get(i), eventNumber.toString)
							}
							res.append("happens(" + causes.get(i) + ",T" + events.get(causes.get(i)))
							res.append(")")
							if (i < causes.length - 1) {
								res.append(" ; ")
							}
						}
						res.append("),")
						res.append("T" + events.get(sProp.interval.situationName.compileState))
						res.append("<=T" + eventNumber)
						eventNumber += 1
					}
				}
			}
			
			res.append(decl.toString)
		}
		return eventNumber
	}
	
	//-----------------------------------------------------------------------//
	//---------------------------Helper Functions----------------------------//
	//-----------------------------------------------------------------------//
	
	/**
	 * Adds a declaration event to the events hashmap
	 */
	def compileAddDeclEvent(String declEvent, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		
		if (!events.containsKey(declEvent)) {
			res.append(",within(E" + eventNumber + ",performer(E" + eventNumber + "," + oblName + ")),")
			res.append(declEvent + "(E" + eventNumber + "),")
			res.append("happens(E" + eventNumber + ",T" + eventNumber + ")")
			events.put(declEvent, eventNumber.toString)
			eventNumber += 1
		}
		
		return eventNumber
	}
	
	/**
	 * Adds a regular event to the events hashmap
	 */
	def compileAddEvent(String event, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		
		if (!events.containsKey(event)) {
			res.append(",happens(" + event + ",T" + eventNumber + ")")
			events.put(event, eventNumber.toString)
			eventNumber += 1
		}
		
		return eventNumber
	}
	
	/**
	 * Adds a regular situation to the events hashmap
	 */
	def compileAddSit(String situation, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		
		if (!events.containsKey(situation)) {
			res.append(",initiates(E" + eventNumber + "," + situation + "),")
			res.append("happens(E" + eventNumber + ",T" + eventNumber + ")")
			events.put(situation, eventNumber.toString)
			eventNumber += 1
		}
		return eventNumber
	}
	
	/**
	 * Adds a declaration situation to the events hashmap
	 */
	def compileAddDeclSit(String declSit, StringBuilder res, int d, String oblName, HashMap<String, String> events) {
		var eventNumber = d
		
		if (!events.containsKey(declSit)) {
			res.append(",initiates(E" + eventNumber + ",S" + eventNumber + "),")
			res.append("happens(E" + eventNumber + ",T" + eventNumber + "),")
			res.append(declSit + "(S" + eventNumber + ")")
			events.put(declSit, eventNumber.toString)
			eventNumber += 1
		}
		return eventNumber
	}
	
	/**
	 * Returns String corresponding to a symboleo operator for points in the form
	 */
	def compileTempOpB(String TempOp) {
		switch (TempOp) {
			case 'BEFORE': return "-"
			case 'AFTER': return "+"
			case '+': return "+"
			case '-': return "-"
		}
	}
	
	def compileTempOpA(String TempOp) {
		switch (TempOp) {
			case 'BEFORE': return "+"
			case 'AFTER': return "-"
			case '+': return "-"
			case '-': return "+"	
		}
	}
	/**
	 * Returns string corresponding to an event
	 */
	def compileEvent(SitName event) {
		if (event.OEvent != null) {
			return event.OEvent.compileOEvent
		}	
		if (event.CEvent != null) {
			return event.CEvent.compileCEvent
		}
		if (event.PEvent != null) {
			return event.PEvent.compilePEvent
		}
	}
	
	/**
	 * Helper functions that return the prolog representation for predefined events
	 */
	 
	def compileOEvent(oEvent event) {
		switch (event.oblEvent) {
			case 'oTRIGGERED': return 'triggered(' + event.oblName + ')'
			case 'oACTIVATED': return 'activated(' + event.oblName + ')'
			case 'oSUSPENDED': return 'suspended(' + event.oblName + ')'
			case 'oRESUMED': return 'resumed(' + event.oblName + ')'
			case 'oDISCHARGED': return 'discharged(' + event.oblName + ')'
			case 'oEXPIRED': return 'expired(' + event.oblName + ')'
			case 'oFULFILLED': return 'fulfilled(' + event.oblName + ')'
			case'oVIOLATED': return 'violated(' + event.oblName + ')'
			case 'oTERMINATED': return 'terminated(' + event.oblName + ')'
		}
	}
	
	def compileCEvent(cEvent event) {
		switch (event.contrEvent) {
			case 'cACTIVATED': return 'activated(' + event.contrName + ')'
			case 'cSUSPENDED': return 'suspended(' + event.contrName + ')'
			case 'cRESUMED': return 'resumed(' + event.contrName + ')'
			case 'cFULFILLED_ACTIVE_OBLS': return 'fulfilled(' + event.contrName + ')'
			case 'cREVOKED_PARTY': return 'revoked(' + event.contrName + ')'
			case 'cASSIGNED_PARTY': return 'assigned(' + event.contrName + ')'
			case 'cTERMINATED': return 'terminated(' + event.contrName + ')'
		}
	}
	
	def compilePEvent(pEvent event) {
		switch (event.powEvent) {
			case 'pTRIGGERED': return 'triggered(' + event.powName + ')'
			case 'pACTIVATED': return 'activated(' + event.powName + ')'
			case 'pSUSPENDED': return 'suspended(' + event.powName + ')'
			case 'pRESUMED': return 'resumed(' + event.powName + ')'
			case 'pEXERTED': return 'exerted(' + event.powName + ')'
			case 'pEXPIRED': return 'expired(' + event.powName + ')'
			case 'pTERMINATED': return 'terminated(' + event.powName + ')'
		}
	}
	
	/**
	 * Returns string corresponding to a situation
	 */
	def compileState(SitName state) {
		if (state.OState != null) {
			return state.OState.compileOState
		}
		if (state.CState != null) {
			return state.CState.compileCState
		}
		if (state.PState != null) {
			return state.PState.compilePState
		}
	}
	
	/**
	 * Helper functions that return the prolog representation for predefined states
	 */
	 
	def compileOState(oState state) {
		switch (state.oblState) {
			case 'oCREATE': return 'create(' + state.oblName + ')'
			case 'oINEFFECT': return 'ineffect(' + state.oblName + ')'
			case 'oSUSPENSION': return 'suspension(' + state.oblName + ')'
			case 'oUNSUCCESSFUL_TERMINATION': return 'unsuccessfulTermination(' + state.oblName + ')'
			case 'oVIOLATION': return 'violation(' + state.oblName + ')'
			case 'oFULFILLMENT': return 'fulfillment(' + state.oblName + ')'
			case 'oDISCHARGE': return 'discharge(' + state.oblName + ')'
		}
	}
	
	def compileCState(cState state) {
		switch (state.contrState) {
			case 'cFORM': return 'form(' + state.contractName + ')'
			case 'cINEFFECT': return 'ineffect(' + state.contractName + ')'
			case 'cSUSPENSION': return 'suspension(' + state.contractName + ')'
			case 'cSUCCESSFUL_TERMINATION': return 'successfulTermination(' + state.contractName + ')'
			case 'cUNSECCESSFUL_TERMINATION': return 'unsuccessfulTermination(' + state.contractName + ')'
			case 'cUNASSIGN': return 'unassign(' + state.contractName + ')'
		}
	}
	
	def compilePState(pState state) {
		switch (state.powState) {
			case 'pCREATE': return 'create(' + state.powName + ')'
			case 'pINEFFECT': return 'ineffect(' + state.powName + ')'
			case 'pSUSPENSION': return 'suspension(' + state.powName + ')'
			case 'pSUCCESSFUL_TERMINATION': return 'successfulTermination(' + state.powName + ')'
			case 'pUNSUCCESSFUL_TERMINATION': return 'unsuccessfulTermination(' + state.powName + ')'
		}
	}
	
	
	def mapStateToEvent(SitName state) {
		if (state.OState != null) {
			return state.OState.mapOStateToEvent
		}
		if (state.CState != null) {
			return state.CState.mapCStateToEvent
		}
		if (state.PState != null) {
			return state.PState.mapPStateToEvent
		}
	}
	
	/**
	 * Helper functions to find the events that lead to certain states
	 */
	 
	def mapOStateToEvent(oState state) {
		switch (state.oblState) {
			case 'oCREATE': return 'triggered(' + state.oblName + ')'
			case 'oINEFFECT': return 'resumed(' + state.oblName + '),activated(' + state.oblName + '),triggered(' + state.oblName + ')'
			case 'oSUSPENSION': return 'suspended(' + state.oblName + ')'
			case 'oUNSUCCESSFUL_TERMINATION': return 'terminated(' + state.oblName + ')'
			case 'oVIOLATION': return 'violated(' + state.oblName + ')'
			case 'oFULFILLMENT': return 'fulfilled(' + state.oblName + ')'
			case 'oDISCHARGE': return 'discharged(' + state.oblName + '),expired(' + state.oblName + ')'
		}
	}
	
	def mapCStateToEvent(cState state) {
		switch (state.contrState) {
			case 'cINEFFECT': return 'activated(' + state.contractName + '),assigned(' + state.contractName + '),resumed(' + state.contractName + ')'
			case 'cSUSPENSION': return 'suspended(' + state.contractName + ')'
			case 'cSUCCESSFUL_TERMINATION': return 'fulfilled(' + state.contractName + ')'
			case 'cUNSECCESSFUL_TERMINATION': return 'terminated(' + state.contractName + ')'
			case 'cUNASSIGN': return 'revoked(' + state.contractName + ')'
		}
	}
	
	def mapPStateToEvent(pState state) {
		switch (state.powState) {
			case 'pCREATE': return 'triggered(' + state.powName + ')'
			case 'pINEFFECT': return 'triggered(' + state.powName + '),activated(' + state.powName + '),resumed(' + state.powName + ')'
			case 'pSUSPENSION': return 'suspended(' + state.powName + ')'
			case 'pSUCCESSFUL_TERMINATION': return 'exerted(' + state.powName + ')'
			case 'pUNSUCCESSFUL_TERMINATION': return 'terminated(' + state.powName + '),expired(' + state.powName + ')'
		}
	}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile('test.pl', resource.allContents.filter(Model).head.compile)
	}
}
